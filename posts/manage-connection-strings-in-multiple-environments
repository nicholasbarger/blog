{"id":"manage-connection-strings-in-multiple-environments","title":"Manage Connection Strings In Multiple Environments","description":"","link":"http://nicholasbarger.com/2009/01/30/manage-connection-strings-in-multiple-environments/","pubDate":"2009-01-30T19:34:12.000Z","content":"Have you ever had to move or deploy applications to different servers and forgotten to change connection strings settings?  Maybe you were developing against a local database and when you push to production your web.config (or wherever you store your connection strings) stayed pointing to your local instead of production.  Another common pain is when moving an application throughout the various stages of the software development lifecycle; perhaps from a development environment, to testing server(s), staging server(s), and finally to production?  In multi-environment development, deployment can become a real headache.There are several different approaches to making this easier, including creating post build scripts, creating a deployment project (which I will probably cover in a future blog post), and simply implementing manual processes to follow.  However, I've found in my own recreational programming, that creating a ConnectionManagement class is a pretty slick and easy way to go that garners all kinds of added benefits.<h2>A Two Environment Example</h2>Let's take the example of developing against a local SQL database (or database project), and deploying directly to production; something which is typically done in very small projects.We want to create a single class that we statically call to retrieve the appropriate connection string, but still maintain the ability to house the connection strings inside an easily configurable file (such as web.config).  In this example, we're not particularly concerned if the seperate environments have knowledge of the other environments' connection strings (this is a potential security risk if you have several developers who have access to web.config via dev server/test server and should not have access to production server, though you can encrypt or take additional measures to protect the connection strings).I create this class in my DataAccess project where the rest of my data logic resides.  Let's set this class up like the following:<h3>ConnectionManager Class</h3><div class=\"c_block\"><pre>public class ConnectionManager    {        public static string GetConnectionString()        {            string appMode = string.Empty;            if (ConfigurationSettings.AppSettings[\"Mode\"] != null)            {                appMode = ConfigurationSettings.AppSettings[\"Mode\"].ToLower();            }            if (appMode == \"prd\")            {                return ConfigurationManager.ConnectionStrings[\"MyDBPrd\"].ConnectionString;            }            else            {                return ConfigurationManager.ConnectionStrings[\"MyDBDev\"].ConnectionString;            }        }    }</pre></div>Make sure you've added <em>using System.Configuration;</em> to the top of your class and if necessary added to your class library/project.What we are doing here is very simple; we're just going to get the appropriate connection string based on an app setting found in the web.config of the <em>calling</em> project.  If the mode is \"prd\" (I know, I'm using hardcoded strings here...tisk, tisk) then return production, if it's anything else return the dev connection string.<h3>Web.Config of Consuming Project</h3>Let's take a look at the web.config app setting we've added to control the connection strings.<div class=\"xml_block\"><pre>&lt;appSettings&gt;      &lt;!-- Possible values are: Dev, Prd--&gt;      &lt;add key=\"Mode\" value=\"Dev\"/&gt;&lt;/appSettings&gt;</pre></div><h3>App.Config of DataAccess Layer</h3>Inside the data access layer, where the connection manager class resides, I have an app.config which houses all of the connection string information.  If you don't use multi-tiered design, this could go in your calling project (webapp?) instead.<div class=\"xml_block\"><pre>&lt;connectionStrings&gt;    &lt;add name=\"MyDBDev\" connectionString=\"Data Source=MY-PC\\SQLEXPRESS;Initial Catalog=MyDB;Integrated Security=True\"/&gt;    &lt;add name=\"MyDBPrd\" connectionString=\"server=localhost;uid=app;pwd=mysecurepassword;database=MyDB;application name=MyApp;Max pool Size=500;Connect Timeout=30;connection reset=false;connection lifetime=5;\"/&gt;&lt;/connectionStrings&gt;</pre></div><h3>Calling Our New ConnectionManager.GetConnectionString() Function</h3>Ok, now that we went to all this trouble, make sure <strong>everywhere</strong> we call a connection string (which should probably only be in our data access layer), we call this method, like so:<h4>Linq Example</h4><div class=\"c_block\"><pre>public static Specy GetSpecies(int SpeciesID){//This next line creates a data context from linq and uses the ConnectionManager.GetConnectionString()//function to get the connection string it uses.  Even though this Linq2SQL data context has a connection//string associated with it, i am setting it in case we change environments.MasterDataContext dc = new MasterDataContext(ConnectionManager.GetConnectionString());        var query = from a in dc.Species        \twhere a.SpeciesID == SpeciesID                select a;        return query.SingleOrDefault();}</pre></div><h4>Traditional ADO.NET Method</h4><div class=\"c_block\"><pre>public static DataTable GetControlSpecies(){//This next line creates a sql connection object and uses the ConnectionManager.GetConnectionString()//function to get the connection string it uses.  Using the same usage everytime and letting the//connection manager dictate which connection based on environment consolidates your code and allows you//to deploy your web applications to different database environments quickly and easily.using (SqlConnection connection = new SqlConnection(ConnectionManager.GetConnectionString()))        {        \tstring sql = \"SELECT SpeciesID, CommonName, ScientificName FROM Species ORDER BY CommonName ASC\";                var cmd = new SqlCommand(sql, connection);                var da = new SqlDataAdapter(cmd);                var dt = new DataTable();                da.Fill(dt);                return dt;}}</pre></div>When you deploy to an environment now you only need to ensure one value is set correctly (the app setting <em>Mode</em> property we created)!  And most of the time, if you're like me, you hardly ever change the web.config after initial setup anyway; so you're all set!<h2>Dealing With Several Environments</h2>In this case we only have two environments, the local copy we develop against, and production...However, what if we have several environments, or several different databases.  To expand on this basic class, we can add a switch/case statement to jump through all of the possible combinations of environments such as the following:<div class=\"c_block\"><pre>public class ConnectionManager    {        public static string GetConnectionString()        {            string appMode = string.Empty;            if (ConfigurationSettings.AppSettings[\"Mode\"] != null)            {                appMode = ConfigurationSettings.AppSettings[\"Mode\"].ToLower();            }    string connectionString = string.Empty;            switch(appMode)            {                case \"prd\": //Production\t\tconnectionString = ConfigurationManager.ConnectionStrings[\"MyDBPrd\"].ConnectionString;\t\tbreak;\tcase \"dev\": //Development\t\tconnectionString = ConfigurationManager.ConnectionStrings[\"MyDBDev\"].ConnectionString;\t\tbreak;\tcase \"tst\": //Test\t\tconnectionString = ConfigurationManager.ConnectionStrings[\"MyDBTest\"].ConnectionString;\t\tbreak;\tcase \"stg\": //Staging\t\tconnectionString = ConfigurationManager.ConnectionStrings[\"MyDBStaging\"].ConnectionString;\t\tbreak;\tcase \"vendor\": //Vendors\t\tconnectionString = ConfigurationManager.ConnectionStrings[\"MyDBVendor\"].ConnectionString;\t\tbreak;\tcase \"local\":  //Local\t\tconnectionString = ConfigurationManager.ConnectionStrings[\"MyDBLocal\"].ConnectionString;\t\tbreak;    }    return connectionString;        }    }</pre></div><h2>Expanding on the ConnectionManager Class</h2>Having a centralized point of entry for accessing your connection strings is helpful for other reasons as well.  Perhaps you need to add custom encryption/decryption to your connection strings, or control access to specific connection strings programmatically.  These, as well as many additional future enhancements can be built into your class and trickled down to all consuming calls.One final note, it may also be helpful to create an enum of different databases to pass as a parameter to the ConnectionManager.GetConnectionString() function such as ConfigurationManager.GetConnectionString(Databases.Users) or ConfigurationManager.GetConnectionString(Databases.Transactions), etc. to use the class to access specific databases on a single server.Thanks for reading, and hope you find this useful!  Please feel free to add any comments or suggestions on managing connection strings!"}