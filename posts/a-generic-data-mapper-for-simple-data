{"id":"a-generic-data-mapper-for-simple-data","title":"A Generic Data Mapper for Simple Data","description":"","link":"http://nicholasbarger.com/2010/03/01/a-generic-data-mapper-for-simple-data/","pubDate":"2010-03-01T02:55:32.000Z","content":"<p>Recently, a buddy and I were working on a project and we came across an almost abnormal amount of simple data entities which were used primarily for populating dropdowns.  You know the type of data, there is essentially an ID, Name, and not much else.</p><p>We needed to do several things with these simple entities, namely populate dropdown, but also associate the entities with other more complex entities.  In our architecture, we’re using a layered approach and manual mappers of data retrieval to business entities.  There were several ways that we could have gone about propagating this data through the DAL, BLL, and to the presentation, but we chose to create individual entities to represent each of these lists of data.  Our reasoning for this was to optimize the ability to separate the code and provide for future classes that could take on additional responsibility if these entities became more complex.</p><p>For these simple entities, we didn’t want to write an individual mapper for each one (essentially a whole lot of cut and paste work); so we opted to create a generic mapper class which is constrained by a base class which all of the simple entities inherit from (SimpleData).</p><p>The SimpleData class is just that, simple, and looks like this:</p><h3>The SimpleData Entity</h3><div class=\"c_block\"><pre>using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Runtime.Serialization;namespace Common.Entities.General{    [DataContract()]    public abstract class SimpleData    {        #region Constructors        public SimpleData()        {        }        public SimpleData(int id)            : this(id, string.Empty, string.Empty)        {        }        public SimpleData(string text, string value) : this(0, text, value)        {                    }        public SimpleData(int id, string text, string value)        {            this.ID = id;            this.DataText = text;            this.DataValue = value;        }        #endregion        #region Properties        public DateTime Created { get; set; }        public string DataText { get; set; }        public string DataValue { get; set; }        public int ID { get; set; }        public DateTime? LastUpdated { get; set; }        #endregion        #region Methods        public abstract SimpleData Create(int id, string text, string value);        #endregion    }}</pre></div><p>Now that we had a base class to inherit from, we needed to apply this to our simple entity to be mapped;  here is one example of our entity inheriting SimpleData:</p><h3>The Entity to be Mapped</h3><div class=\"c_block\"><pre>using System;using System.Collections.Generic;using System.Linq;using System.Text;namespace Common.Entities.General{    ///     /// An arbitrary class implementing SimpleData.    ///     public class CallType : SimpleData    {        #region Constructors        public CallType()        {        }        public CallType(int id)            : this(id, string.Empty, string.Empty)        {        }        public CallType(string text, string value) : base(text, value)        {                    }        public CallType(int id, string text, string value)            : base(id, text, value)        {        }        #endregion        public override SimpleData Create(int id, string text, string value)        {            return new CallType(id, text, value);        }    }}</pre></div><p>Now that we had a consistent approach to marking up the simple entities, we could create a single generic mapper class called “SimpleMapper”.  The class takes in a DataRow, the name of the ID field, the name of the textual (Name) field, and the name of the value field (specifically, if this is different than the ID).</p><p>The reason we have a few extra input parameters here is so the SimpleMapper could handle for these two scenarios (we’ll use our Call Type as the example):</p><ul><li>Scenario 1:  My data has an integer ID for the unique identifier of the database record and the name of the Call Type  as the textual value.  My database table could look like this:</li></ul><table border=\"1\"><tr>\t<td colspan=\"2\"><strong>CallTypes Database Table</strong></td></tr><tr>\t<td>ID</td>\t<td>int</td></tr><tr>\t<td>Name</td>\t<td>varchar(50)</td></tr></table><ul><li>Scenario 2:  My data has an integer ID for the unique identifier of the database record, a name of the Call Type as the textual value, and a 3-digit textual code for the CallType.  My database table could look like this:</li></ul><table border=\"1\"><tr>\t<td colspan=\"2\"><strong>CallTypes Database Table</strong></td></tr><tr>\t<td>ID</td>\t<td>int</td></tr><tr>\t<td>Name</td>\t<td>varchar(50)</td></tr><tr>\t<td>Code</td>\t<td>varchar(3)</td></tr></table><p>By specifying which column should be returned as the DataValue field (either the ID, the code, or even the textual name itself) the class has a little more flexibility.  Below is the SimpleMapper class in its entirety: </p><h3>The SimpleMapper Class</h3><div class=\"c_block\"><pre>using System;using System.Collections.Generic;using System.Linq;using System.Text;using Common.Entities.General;using System.Data;namespace DataAccess.Full{    public class SimpleMapper where T : SimpleData, new()    {        public static T Map(DataRow row, string idName, string textName, string valueName)        {            var creator = new T();            int id = (int)row[idName];            string text = (string)row[textName];            string value = id.ToString();            if (idName != valueName)            {                value = (string)row[valueName];            }            var obj = creator.Create(id, text, value);                        return (T)obj;        }        public static T[] Map(DataTable data, string idName, string textName, string valueName)        {            var entities = new List();            foreach (DataRow row in data.Rows)            {                entities.Add(Map(row, idName, textName, valueName));            }            return entities.ToArray();        }    }}</pre></div>"}